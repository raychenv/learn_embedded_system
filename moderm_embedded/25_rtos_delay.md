# 嵌入式RTOS - 高效阻塞线程

延时函数是我们常见的调用，我们有两种选择：  
一是，不断的轮询某个count，直到count到某个数值，轮询退出，如Miro Samek实现的`BSP_delay()`   
二是，换出当前的任务，切换到另外一个任务上，等待超时通知，再去调度挂起的任务  

程序比较简单，实时性要求不高，没有几个任务的场景，我们可以选择第一种方案，实现起来会非常简单。当面临复杂并且实时性要求高的多任务场景时，第二种方案几乎是必选。

Miro Samek博士的现代嵌入式系统编程课程25讲生动讲解了第二种方案的实现。
https://github.com/QuantumLeaps/modern-embedded-programming-course/tree/main/lesson-25/tm4c123-keil

## 优化`BSP_delay()`
![bsp_delay](./images/bsp_delay.drawio.svg)
如图所示，可以称之为线程加Systick中断运行缩略图。虽然系统能够完全自主运行，对线程执行简单的轮转调度（多个线程图中已略去，只有一个线程保留）。线程调用`BSP_delay()`使用原始的轮询机制延迟一段时间。Systick中断处理返回后仍然占用CPU周期。显然，这是低效的，浪费了CPU周期。CPU这样的机器打工人，我们怎么能让它歇着呢？！  

如何优化呢？**上下文切换**(Context Switch)。`delay()` 函数不再使用循环轮询，而是可以将上下文从延时线程切换出去，延时期满后再切换回来。在此期间，线程将被**阻塞**，完全不消耗CPU周期。  
![os_delay](./images/os_delay.drawio.svg)
如上图所示，需要延迟同样一段时间，这里调用`OS_Sched()` 触发**PendSV**中断进行上下文切换，然后线程进入**阻塞**状态。延时时间在**Systick**中断处理更新。延时到期后，**Systick**中断处理函数里面调用`Os_Sched()`进行**上下文切换**。线程从**阻塞**状态被重新调度。  
从线程角度看，阻塞延时的行为与轮询完全相同：`delay()` 函数直到时间到期才返回。但从系统角度看，这是巨大的改进——CPU 现在可以自由地为其他线程做有用的工作。      
因为它需要调度器和**上下文切换**，所以我们将这个系统服务称为 `OS_delay()`。这种转变——将 `delay()` 等功能从应用层移到系统层——是现代软件系统的广泛趋势。  

## 线程状态图
![thread_sm](./images/thread_state_machine.drawio.svg)   
轮询的状态图如上。在生命周期中，线程从**休眠**状态开始（不可运行），然后通过 `OSThread_start()` 转换到**抢占**状态。当线程被选中运行时，进入**运行**状态。同时只能有一个线程处于**运行**状态。
![thread_blocking](./images/thread_blocking.drawio.svg)  
如果运行中的线程调用 `OS_delay()`，它转换到**阻塞**状态。更新后的状态图如上。
**阻塞**线程。处于轮询延时（BSP_delay()）的线程仍然参与轮转调度——有时运行，有时不运行。相比之下，处于**阻塞**状态的线程**未就绪**，不能被调度。    
在这种设计下，线程从**休眠**状态开始（不可运行），然后通过 `OSThread_start()` 转换到**抢占**状态。当线程被选中运行时，进入**运行**状态。同时只能有一个线程处于运行状态。如果运行中的线程调用 `OS_delay()`，它转换到**阻塞**状态。  
要离开阻塞状态，系统服务必须检测延时是否结束。这通过时钟节拍中断定期调用 `OS_tick()` 完成。`OS_tick()` 更新延时计数器并解除任何延时已到期线程的阻塞。

## 系统延时机制实现

首先呢，需要为每个 `OSThread` 对象增加私有超时计数器**timeout**。当线程调用 `OS_delay()` 时，设置计数器。每个时钟节拍，`OS_tick()` 递减这些计数器。当计数器达到零时，相应线程再次就绪。我们可以看Blink1加Blink2两个线程运行时示意图，如下。
![os_delay_design](./images/os_delay_runtime.drawio.svg)  

**阻塞**状态的引入带来另一个需求：**Idle空闲线程**。如果所有线程都被**阻塞**，RTOS仍需要运行某些内容——那就是**空闲线程**。这个特殊线程永远不会**阻塞**，当没有其他线程就绪时提供安全回退。空闲线程本身仍在浪费**CPU周期**。那么我们能做什么？
我们可以使用**低功耗睡眠模式**。ARM Cortex-M CPU 提供 `WFI`（等待中断）指令，该指令暂停 CPU 直到下一个中断。可以在 `OS_onIdle()` 内调用 `__WFI()`。  

![os_delay_design](./images/os_delay_design.drawio.svg)  
如上图，我们使用32位位掩码 `OS_readySet` 而不是单独跟踪线程就绪状态，其中每位代表一个线程（排除索引 0 的空闲线程）。如果某位被设置，该线程就绪运行。空闲线程始终就绪且不包含在此位掩码中。   
在调度器中，我们首先检查 `OS_readySet` 是否为零。如果是，运行空闲线程。否则，循环遍历 `OS_thread[]`（跳过索引 0）直到找到下一个就绪线程。

实现部分主要是`OS_delay()` 和`OS_tick()`。详见代码库～～

## 总结
参考Miro Samek课程25课的讲解，总结了带线程阻塞的RTOS的大致实现，类似于1960年代早期的技术水平。后面，26课添加了**基于优先级的抢占式调度**，是这1970年代技术了。