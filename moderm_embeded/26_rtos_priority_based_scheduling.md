# 26 什么是实时抢占和优先级调度

Miro Samek 25课里实现了高效的延时函数`OS_delay()`。然后，所开发的MiROS RTOS并不满足实时性要求，因为轮转调度策略（Round Robin）并不具备实时性。课程从实时性概念开始解释了为什么轮转调度策略不具备实时性，进一步地，导入实时性的解决方案--实时抢占和优先级调度。

25课实时抢占和优先级调度实现可见：
https://github.com/QuantumLeaps/modern-embedded-programming-course/tree/main/lesson-26/tm4c123-keil 

## 什么是实时呢？
“实时"为计算添加了时效性要求。执行得太晚（或太早）的计算被认为用处较小且可能有害——就像彻底错误的计算一样。在*硬实时系统*中，从触发事件到截止时间之前，计算都是有用的。在截止时间之后，有用性变成"负无穷"，意味着比无用更糟糕。错过截止时间代表系统故障。
例如，安全气囊展开太晚不仅仅是无用的——而是灾难性的。

![airbag](./images/airbag.png)  

相比之下，*软实时系统*在时间上更加灵活。文本消息预期在20秒内到达，但更长时间后到达仍然有用。  

![soft hard realtime](./images/hard_soft_real_time.drawio.svg)

从历史上看，计算机在此类系统中的主流应用始于20世纪60年代和70年代。例如，阿波罗计划使用了两台相同的实时计算机——一台在指令舱，一台在登月舱。Margaret Hamilton领导了这项工作的大部分内容，有一张著名的照片显示她站在一摞代码清单旁边。

<img src="./images/hamilton1969.png" alt="hamilton1969" width="50%" height="50%"> 

即使在那时，工程师们就意识到大多数实时系统都是周期性运行的，事件和截止时间以固定速率重复。
例如，宇宙飞船着陆需要每隔几毫秒调整推进器。

<img src="./images/lander.png" alt="lander" width="50%" height="50%">

同样，工业或发动机控制需要定期计时——从毫秒到秒不等。
实时系统任务切换遵循着高优先级的任务抢占优先级低任务，如下图所示。Thread#1具有更高优先级，为保证其运行截止时间，可以抢占Thread#2的执行，执行结束后，让出CPU给Thread#2。

![realtime_sch](./images/real_time_sch.drawio.svg)

## 轮转调度器的实时性问题
为了更好地理解实时概念如何应用于周期性线程，让我们做一些实验。首先，将系统时钟滴答率提高到每秒1000次——每毫秒一次滴答。然后修改`blinky1`和`blinky2`线程以增加一些计算负载。以前，它们在一微秒内切换LED然后阻塞。现在，用一个`for`循环模拟CPU使用，该循环切换LED数千次。循环大约需要1.2ms——略长于一个时钟滴答。循环结束后，`blinky1`延迟一个滴答，意味着其循环每2ms重复一次。

这里引入一些符号。设`C1 = 1.2ms`为线程1（`blinky1`）的计算时间，`T1 = 2ms`为其周期。CPU利用率`U1 = C1/T1 = 60%`。同样，修改`blinky2`运行约3.6ms，然后延迟50ms。所以`T2 = 54ms`，`C2 = 3.6ms`，`U2 ≈ 6.6%`。时间线示意图如下：
![blink12](./images/blinky12_sch.drawio.svg)
在构建之前，注释掉`OS_onIdle()`中的`WFI`（等待中断）指令以保持CPU活跃。

当系统运行时，`ISR`跟踪显示1ms SysTick。`T1`运行1.2ms并每2ms重复一次。`T2`运行3-4ms并每55ms重复一次。空闲线程在没有其他任务时运行。关键时刻是当`blinky1`和`blinky2`都就绪时。`blinky1`开始运行但在下一个滴答被`blinky2`抢占。`blinky1`稍后恢复但错过了2ms截止时间。这是因为MiROS使用轮转调度器，它试图**公平共享**CPU时间——而不是优先考虑截止时间。

## **基于优先级的抢占式调度器**
想象`blinky1`控制月球下降并且必须满足2ms截止时间。你不关心公平性；需要一个尊重线程*重要性*的调度器。这就是为什么要实现一个**基于优先级的抢占式调度器**，具有静态优先级。每个线程获得固定优先级，调度器总是运行最高优先级的就绪线程。

![roundrobin](./images/round_robin_sch.drawio.svg)
![prioritybased](./images/priority_based_sch.drawio.svg)

让我们看看时间线。当只有`T1`就绪时，两种调度器行为相同。当`T2`变为就绪时，轮转调度器暂停`T1`，这导致错过2ms截止时间，如上图所示。但基于优先级的调度器看到`T1`有更高优先级并保持其运行，所以它满足截止时间。只有当`T1`阻塞时`T2`才运行。即使`T2`被延迟，它仍然在54ms截止时间之前完成。

如何实现的？
1. 升级MiROS版本并在线程控制块和`OSThread_start()`函数中添加`priority`字段。优先级范围从0到31（适合`uint8_t`）。
2. `OS_thread[]`数组现在使用优先级作为索引——而不是连续的线程ID。所以`OS_thread[prio]`直接映射到具有该优先级的线程。
3. 位掩码`OS_readySet`帮助跟踪哪些线程就绪。
4. 还需要`OS_delayedSet`来跟踪延迟的线程。
5. 要找到最高优先级的就绪线程，在32位位掩码上使用**前导零计数**（CLZ）指令。在ARM Cortex-M上，这通过`__clz()`内联函数很高效。LOG2宏将计算`32 - CLZ(x)`，给出优先级。
6. 在`OS_sched()`中使用这个来选择`OS_next`。如果没有线程就绪，运行空闲线程。否则，使用`LOG2(OS_readySet)`获取最高就绪线程。
7. 重新设计`OS_tick()`仅处理活跃的延迟线程。在延迟集合的工作副本上使用`LOG2()`进行迭代。对于每个活跃线程，减少其超时，如果达到零，将其移动到就绪集合并从延迟集合中删除。使用临时`bit`变量避免重复。
8. 在`OS_delay()`中，从就绪集合中删除线程并将其添加到延迟集合。再次使用`bit`简化代码。
`OS_readySet`和`OS_thread[prio]`映射样例如下：

![priority_based](./images/priority_based_design.drawio.svg)

## **阻塞是关键的**
高优先级线程想运行多长时间就运行多长时间；低优先级线程只能在高优先级线程**阻塞**时运行。没有阻塞，低优先级线程**永远不会**运行。这与轮转不同，轮转中所有线程都会轮到。
这就是为什么在添加优先级调度之前首先实现高效阻塞（在第25课）。

## **最重要的设计决策**：分配优先级
有两个线程，你只有两个选择：给`blinky1`更高或更低的优先级。如你所见，分配`blinky1`更高优先级有效——两个截止时间都满足。相反则失败。  
新兴规则：将更高优先级分配给周期更短的线程（即更紧的截止时间）。

这个规则在1973年由C.L. Liu和James Layland在他们的经典论文*"硬实时环境中多道程序的调度算法"*中正式化。他们的方法被称为**速率单调分析（RMA）**或**速率单调调度（RMS）**。

RMA基于线程速率分配优先级：更快（更短周期）的线程获得更高优先级。指导原则是：
1. 单调分配优先级——更短周期=更高优先级。
2. 计算每个线程的CPU利用率：`U = C/T`。
3. 求和所有利用率。如果总和低于理论界限，保证满足所有截止时间。

这个界限`U(n)`取决于线程数量。对于大`n`，它接近`ln(2) ≈ 0.693`。所以，保持在70%利用率以下确保可调度性。

对于`blinky1`和`blinky2`，总利用率是`0.6 + 0.066 = 0.666`，低于界限——所以保证截止时间。该模型可以通过考虑最坏情况时序扩展到非周期线程或具有可变执行时间的线程。

在实践中，只有少数线程有硬实时要求。分配它们更高优先级，并将软实时线程保持在较低优先级。抢占式基于优先级调度器的美妙之处在于其**时间隔离**：高优先级线程不受低优先级线程的延迟或过度使用影响。

这种调度策略现在是大多数RTOS的标准。
